# 类的作用域
在类的作用域外，普通的数据和函数成员只能由对象、指针或引用通过**成员访问符**访问，类类型成员则使用**作用域运算符**访问。
```cpp
Screen::pos ht=24,wd=80;        //使用Screen定义的pos类型(::)
Screen scr(ht,wd,' ')           //定义一个类对象
Screen *p=&scr;                 //定义一个指向类对象的指针
char c=scr.get();               //访问scr的get成员
c=p->get();                     //访问p所指对象的get成员
```
## 作用域和定义在类外部的成员

在类的外部定义成员函数必须同时提供类名和函数名，这是因为`在类的外部，类的成员会被隐藏起来`。<br>
一旦遇到类名，定义的剩余部分（**参数列表和函数体**）自然包含在类的作用域中，这样使用类的其他成员就无须再次授权。
```cpp
void Window_mgr::clear(ScreenIndex i){
    Screen &s=Screens[i];
    s.contents=string(s.height*s.width,' ');
};
```
另一方面，由于函数的返回类型通常出现在函数名之前（不属于“剩余部分”），所以`当成员函数定义在类的外部时，返回类型的名字位于类的作用域外，需要指明属于哪个类。`
```cpp
class Window_mgr{
public:
    ScreenIndex addScreen (const Screen&);
    //向窗口添加一个新的Screen，返回其编号
};
Window::ScreenIndex 
Window::addScreen(const Screen& s){
    Screens.push_back(s);
    return Screens.size()-1;
}
```

# name lookup
**namelookup**:
* 首先，在名字所在的块内寻找其声明语句，只考虑在**名字的使用之前**出现的声明。
* 如果没找到，继续查找**外层作用域**。
* 如果最终没有找到匹配的声明，则程序报错。<br>
对于定义在**类内部**的成员函数有所区别:
* 首先，编译**成员的声明**。
* 直到类**全部可见**才编译函数体。<br>
`Note:编译器处理完类中的全部声明后才会处理成员函数的定义。`

## 用于类成员声明的名字查找
```cpp
typedef double Money;
string bal;
class Account{
public:
    Money balance(){return bal;}
private:
    Money bal;
};
```
当编译器处理balance（）函数声明时，它将在Account中寻找Money的声明。只考虑Account中使用Money前出现的声明，当没找到匹配的成员时，再到外层作用域中继续寻找，找到typedef，从而确定balance（）返回类型和bal的类型，另一方面，balance返回的是数据成员bal，而不是外层作用域的string对象。

## 类型名要特殊处理
```cpp
typedef double Money;
class Account{
public:
    Money balance(){return bal;}
private:
    typedef double Money;         //error
    Money bal;
};
```
在类中，如果成员使用了外层作用域中每个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。<br>
`Note:类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都在类型名定义之后。`

## 成员定义中的普通块作用域的名字查找
成员函数中使用的名字按照如下方式解析:
* 首先，在成员函数中寻找该名字的声明，只有在**函数使用前**出现的声明才被考虑
* 如果在成员函数内没有找到，则在类中继续查找，这时**类的所有成员**都可以被考虑
* 如果类内也没有找到该名字的声明，在**成员函数定义前的作用域**内继续查找<br>
`Note:成员函数内->类（所有成员）->外层作用域（成员函数定义前）`
```cpp
int height;
class Screen{
public:
    typedef std::string::size_type pos;
    void dummy_fcn(pos height)
    {
      cursor=width*height;    //哪个height?是那个参数
    }
private:
    pos cursor=0;
    pos height=0,width=0;
};
```
该例中，height隐藏了同名的成员
```cpp
//不建议的写法:成员函数中的名字不应该隐藏同名的成员
void Screen::dummy_fcn(pos height){
    cursor=width*this->height;
    //
    cursor=width*Screem::height
};
```
`Note:尽管类的成员被隐藏了，但仍可以通过加上类的名字或显示地使用this指针来强制访问成员。`
```cpp
//建议的写法:不要把成员名字作为参数或其他局部变量使用
void Screen::dummy_fcn(pos ht){
    cursor=width*height;
};
```

## 类作用域之后，在外围的作用域中查找
如果要只用外层作用域中的height，但又被height成员隐藏，这时可以显式地通过作用域运算符来进行请求:
```cpp
//不建议的写法
void Screen::dummy_fcn(pos height){
    cursor=width*::height;
};
```

## 在文件中名字的出现出对其进行解析
```cpp
int height;
class Screen{
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height=0;
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var){
    //height:类的成员
    //verify:全局函数
    //var:参数
    height=verify(var);
}
```
强调一下名字查找的第三步是在成员函数之前的作用域内，所以verify可以正常使用
