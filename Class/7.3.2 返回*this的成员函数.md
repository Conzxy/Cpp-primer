# 返回*this的成员函数

我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任意给定位置的字符
```cpp
class Screen{
public:
    Screen &set(char);              
    Screen &set(pos,pos,char);
};
inline Screen &Screen::set(char c){
    contents[cursor]=c;             //设置当前光标所在位置的新值
    return *this;
}
inline Screen &Screen::set(pos r,pos col,char ch)
{
    contents[r*width+col]=ch;       //设置给定位置的新值
    return *this;
}
```
和move操作一样，我们的set成员的返回值是调用set的对象的引用。返回引用的函数是`左值`的，与意味这些函数返回的是`对象本身而非对象的副本`。
```
myscreen.move(4,0).set('#');
```
这些操作将在同一个对象上执行。

所以也可以写成:
```
myscreen.move(4,0);
myscreen.set('#');
```
如果我们令move和set返回Screen而非Screen&，则上述语句的行为将大不相同，在此例等价于:
```
Screen temp=myscreen.move(4,0);     //对返回值进行拷贝，若是引用则可以避免拷贝，返回对象本身
temp.set('#');                      //不会改变myscreen的contents
```
假如当初我们定义的返回类型不是引用，则`move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myscreen的值`。

## 从const 成员函数返回*this

接下来。我们继续添加一个display的操作，负责打印Screen的内容

从逻辑上看，display不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象，
然而，如果真的令display返回一个const reference，则我们不能将display嵌入一组动作的序列中去:
```cpp
Screen myscreen;
//如果display返回常量引用，则调用set将引发错误
myscreen.display(cout)。set('*');
```
即使myscreen是个non-const object，对set的调用也无法通过编译。问题在于display打的const版本返回的是const reference，而我们无权set一个const object

## 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载。

* 因为non-const function对于const object是不可用的，所以我们只能在一个const object上调用const member function

* 另外，虽然可以在non-const object上调用const type或non-const type但显然此时编译器会优先选择non-const type
```cpp
class Screen{
public:
        Screen &display(std::ostream &os)
        {do_display(os);return *this;}
        const Screen &display(std::ostream &os)const
        {do_display(os);return *this;}
private：
        void do_display(std::ostream& os)const{os<<contents;}
};
```
当一个成员调用另一个成员时，this指针在其中隐式地传递。

因此，当display调用do_display时，它的this指针隐式地传递给do_display，而display的non-const type调用do_display时，它的this指针将隐式地从指向non-const的指针转化为指向const的指针。

当do_display完成后，display函数各自返回解引用this所得的对象。

* non-const type:this指向non-const object,return non-const reference

* const type:return const reference
```cpp
Screen myscreen(5,3);
const Screen black(5,3);
nyscreen.set('#').display(cout);     //调用non-const type
black.display(cout);                 //调用const type
```
