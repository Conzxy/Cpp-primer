# 7.3.1 类成员再探

## 定义一个类型成员

Screen表示显示器的一个窗口。<br>
除了定义member data和member functions外，类还可以`自定义某种类型在类中的别名`。<br>
```cpp
class Screen{
public:
  typedef std::string::size_type pos;
 private:
  pos cursor=0;//光标位置
  pos height=0,width=0;//屏幕的高和宽
  std::string contents;
  };
  ```
 pos之所以定义为public，是因为用户不应该知道Screen使用了一个string对象来存放它的数据，这样有利于隐藏Screen实现的细节。
 
 关于pos，注意两点
 * typedef或using
 * 用于定义类型的成员必须先定义后使用
 
 ## Screen的成员函数
 ```cpp
 class Screen{
 public:
   typedef std::string::size_type pos;
   //constructor
   Screen()=default;
   Screen(pos ht,pos wd,char c):height(ht),width(wd),contents(ht*wd,c){}
   //menber functions
   char get()const                        //读取光标处的字符
         {return contents[cursor];}       //隐式内联
   inline char get(pos ht,pos wd)const ;  //显式内联
   Screen &move(pos r,pos c);             //能在之后被设为内联
 private:
  pos cursor=0;
  pos height=0,width=0;
  std::string contents;
 };
 ```
 **Note**:char get()const为const成员函数
 
 * 表示this是指向常量类对象的常量指针，因此只有const类对象能调用const成员函数
 
 * 一个成员函数，如果对数据成员只涉及读操作，而不进行修改操作，则尽可能声明为const成员函数
 
 ## 令成员作为内联函数
 
 在类中，常有一些规模较小的函数适合于被声明成内联函数。<br>
 
 定义在类内部的成员函数是自动inline的，因此Screen的构造函数和返回光标所指字符的get函数默认是inline function
 
 在类内部也可以显式地声明成员函数，inline关键词主要是用于在类外部声明inline function
 
 ```cpp
 inline
 Screen &Screen::move(pos r,pos c)
 {
      pos row=r*width;                //计算行的位置
      cursor=row+c;                   //在行内将光标移动到指定的列
      return *this;                   //以左值形式返回对象
 }
 char Screen::get(pos r,pos c)const
 {
      pos row=r*width;
      return contents[row+c];         返回给定列的字符
 }
 ```
 
## 重载成员函数

与非成员函数非常相似

For Example:
```cpp
Screen myscreen;
char ch=myscreen.get();
ch=myscreen.get(0,0);
```

## 可变数据成员（multable data member）

由于我们希望能修改类的某个数据成员，即使是在一个const成员函数中。通过在变量的声明中假如mutable关键词即可。
```cpp
class Screen{
public:
    void some_member()const;      
private:
    mutable size_t access_ctr;      //即使在一个const对象内也能被修改
};
void Screen::some_member()const{
    ++access_ctr;                   //用于记录成员函数被调用的次数
}
```
可变数据成员永远不会const。即使它是const对象的成员。因此任何成员函数，包括const函数都能改变它的值

>C++中mutable关键字存在的必要性是什么？<br>
我理解的mutable只是为了在类的const函数里改变类的成员变量值，那为什么不直接把函数的const去掉而要使用mutable关键字呢？<br>
这里感觉我对mutable可能存在误解，或者没有从根本上理解mutable存在的必要性，请大家帮个忙解答一下<br>

>一码归一码。<br>
const意思是“这个函数不修改对象内部状态”。<br>
为了保证这一点，编译器也会主动替你检查，确保你没有修改对象成员变量——否则内部状态就变了。<br>
mutable意思是“这个成员变量不算对象内部状态”。<br>
比如，你搞了个变量，用来统计某个对象的访问次数（比如供debug用）。
它变成什么显然并不影响对象功用，但编译器并不知道：它仍然会阻止一个声明为const的函数修改这个变量。<br>
把这个计数变量声明为mutable，编译器就明白了：这个变量不算对象内部状态，修改它并不影响const语义，所以就不需要禁止const函数修改它了。<br>

## 类数据成员的初始值

继续定义一个窗口管理类并用它表示显示器上的一组Screen。

这个类将包含一个Screen类型的vector，每个元素是一个特定的Screen。

默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11新标准中，最好的方式就是`把这个默认值声明成一个类内初始值`。

```cpp
class Window_mgr{
private:
    //默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
    std::vector<Screen>screens{Screen(24,80,' ')};
};
```
当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在这里，我们使用一个单独的元素值对vector成员执行了list initialization,
这个Screen的值传递给vector<Screen>的构造函数，从而创建一个单元素的vector对象。

**类内初始化**

* 必须使用=的初始化方式(Screen data menber)

* 或花括号括起来的直接初始化(Screen)

